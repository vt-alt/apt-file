#!/bin/bash

shopt -s extglob

usage() {
  [ "$1" ] && echo "Unknown option $1"
  echo "Usage: apt-file [command] pattern [options]"
  echo
  echo "Options:"
  echo
  echo "  -i -w -E -P -G -F        grep options"
  echo "  --arch|-a <arch>         only search this architecture"
  echo "  --package-only|-l        show paga names only"
  echo "  --show=arch|-A           show architectures"
  echo "  --pkglist|-q             search local pkglist database"
  echo
  echo "Commands:"
  echo
  echo "    update                 update index (default is to auto-update"
  echo "                           once per day)"
  echo "    search|find <pattern>  search pattern in files (default)"
  echo "    list|show <pattern>    list files in package"
  exit
}

declare -a arch=($HOSTTYPE noarch)
declare pkglist=
declare update=auto search= show= escape=
declare -a args grep
while [ $# -gt 0 ]; do
  declare opt="$1" arg="$2" ac=1
  case "$opt" in
    --*=*) arg="${opt#*=}"; ac=0 ;;
  esac
  case "$opt" in
    -i|-E|-P|-G|-w|--file=*|-c) grep+=($opt) ;;
    -F|--substring-match) escape=true ;;
    --show=arch|-A) show=arch ;;
    --arch*|-a) arch=("$arg"); shift $ac ;;
    --noarch|--x86_64|--i586) arch=("${opt#--}") ;;
    --pkglist|--local|-q) pkglist=query ;;
    --package-only|--packages|-l) package=only ;;
    --help|-h) usage ;;
    *) args+=("$opt") ;;
  esac
  shift
done
set -- "${args[@]}"

ac=1
if [[ "$1" =~ ^up(d(a(te?)?)?)?$ ]]; then update=verbose; shift; fi
if [[ "$1" =~ ^s(e(a(r(ch?)?)?)?)?$ ]]; then
  search=file
elif [[ "$1" =~ ^f(i(nd?)?)?$ ]]; then
  search=file
elif [[ "$1" =~ ^l(i(st?)?)?$ ]]; then
  search=package
elif [[ "$1" =~ ^s(h(ow?)?)?$ ]]; then
  search=package
elif [[ "$1" =~ ^h(e(lp?)?)?$ ]]; then
  usage
else
  ac=0
fi
shift $ac

if [[ -z "$*" && "$update" != verbose ]]; then
  usage
fi

# legacy
search_contents_index() {
  apt-repo | grep -o 'file:[^ ]* [^ ]*' | sort -u | while read repo arch; do
    [[ $repo =~ ^file: ]] || continue
    ci=${repo#file:}/$arch/base/contents_index
    [ ! -s $ci ] && continue
    grep "$@" < $ci | awk '{print$2": "$1}' | grep --color "$@"
    ret=$?
  done
}

cache=~/.cache/apt-file
apf_cache=/var/cache/apf
if [ $USER = root ]; then
  cache=$apf_cache
fi

newer_index() {
  local a=$1

  ui=$cache/index.$a
  si=$apf_cache/index.$a
  if [ $ui -nt $si ]; then
    echo $ui
  else
    echo $si
  fi
}

search_index() {
  local sharch=
  local e="$*"

  if [ $escape ]; then
    e="${e//\\/\\\\}"
    e="${e//./\.}"
    e="${e//\*/\*}"
  fi
  for a in ${arch[@]}; do
    aq=${a/_/%5f}
    if [ "$show" = arch ]; then
      sharch="\"$a: \""
    fi
    idx=$(newer_index $a)
    if [ "$pkglist" ]; then
      find /var/lib/apt -type f -name '*_'$aq'_base_pkglist.classic' | while read pl; do
	pkglist-query '[%{FILENAMES}\t%{NAME}\n]' $pl
      done
    else
      cat $idx
    fi | if [ "$search" = package ]; then
      grep "${grep[@]}" -e $'\t'"$e$"
    elif [ "$search" = file ]; then
      grep "${grep[@]}" -e "$e.*"$'\t'
    else
      grep "${grep[@]}" -e "$e"
    fi | if [ "$package" = only ]; then
	awk -F '\t' "{print$sharch\$2}" | sort -u | grep --color "${grep[@]}" -e "$e" -e '$'
      else
	awk -F '\t' "{print$sharch\$2\": \"\$1}" | grep --color "${grep[@]}" "$e"
    fi
  done
}

update_index() {
  local a=$1

  if [ "$update" = verbose ]; then
    ropt=--info=progress2
  else
    if [[ -e $cache/index.$a && -n "$(find $cache/index.$a -type f -ctime -1)" ]]; then return; fi
    # do not auto-update if root keeps updated indices
    if [[ -e $apf_cache/index.$a && -n "$(find $apf_cache/index.$a -type f -ctime -1)" ]]; then return; fi
    ropt=-q
  fi
  set -e # for ^C
  of=$cache/index.$a
  [ "$update" = verbose ] && echo -n Updating $a...
  url=rsync.altlinux.ru::ALTLinux/Sisyphus/$a/base/contents_index
  if [ -n "$(rsync --no-motd --dry-run --out-format=%n $url $of)" ]; then
    [ "$update" = verbose ] && echo
    (umask 022; rsync -a -z --no-motd $ropt $url $of)
  else
    [ "$update" = verbose ] && echo " is up to date."
  fi
  chmod 644 $of # touch ctime
  set +e
}

update_indices() {
  if [ ! -d $cache ]; then
    mkdir -p $cache
  fi
  for a in ${arch[@]}; do
    update_index $a
  done
}

if [ $update ]; then
  update_indices
fi

if [ "$*" ]; then
  search_index "$@"
fi
